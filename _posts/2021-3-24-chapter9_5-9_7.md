# 9.5~9.7

## 9.5 Variants of the Basic Convolution Function

- 하나의 커널(kernel)은 오직 하나의 특징만을 뽑을 수 있기 때문에, 신경망에서는 여러 커널을 동시에 사용한다.
- 일반적으로 입력 데이터가 어떤 격자형태의 실수값이 아니라 격자형태의 벡터값(이미지의 경우 RGB에 해당)이기 때문에 입력데이터, 출력데이터 그리고 커널 모두 3-D 텐서인 경우가 많다. (Batch까지 고려한다면 4-D)
    - 4-D 커널 $\mathsf K_{\text{in-channel,out-channel,row,column}}$가 있다고 하면 입력 $\mathsf V_{\text{channel,row,column}}$ 에 대한 출력 $\mathsf Z_{\text{channel,row,column}}$는 다음과 같이 쓸 수 있다.

        $$\mathsf Z_{i,j,k} = \sum_{l,m,n}\mathsf V_{l,j+m-1,k+n-1}\mathsf K_{i,l,m,n}$$

        인덱스에 -1이 붙은 이유는 C나 Python에서는 인덱스가 0으로 시작하기 때문.

- Downsampling convolution

    출력에서 $s$번째 픽셀만 가져오는 방법. ($s$ : stride) 

    모든 픽셀에 대해 컨볼루션을 계산한 후 downsampling하는 것은 코스트가 크기 때문에 아래의 식과 같이 컨볼루션을 $s$번째 픽셀에 대해서만 하는게 좋다.

    $$\mathsf Z_{i,j,k} = c(\mathsf K,\mathsf V, s)=\sum_{l,m,n}\mathsf V_{l,(j-1)\times s+m,(k-1)\times s+n}\mathsf K_{i,l,m,n}$$

    ![_config.yml]({{ site.baseurl }}/assets/ch9/Fig9_12.png)

- Zero-padding

    컨볼루션을 하게 되면 출력 데이터는 입력데이터보다 크기가 작아지기 때문에 컨볼루션을 진행하기 전에 입력데이터에 zero-pad를 하는 방법. 

    제로 패딩을 사용하면 커널의 크기, 출력데이터의 크기를 조절하기 쉬워진다.

    - MATLAB에서 제공되는 세가지 패딩 옵션
        - valid

            커널의 모든 픽셀이 입력 이미지에 포함될때 까지만 컨볼루션하는 방법. 출력 이미지의 크기 : m-k+1 (m : input size, k : kernel size)

        - same

            입력과 출력 이미지의 크기가 같아지도록 제로패딩을 하는 방법. 입력 이미지의 테두리 픽셀들의 영향이 작아지는 단점이 있다.

        - full

            컨볼루션이 진행될 때 k번 방문되는 픽셀의 모든 방향으로 제로패딩을 하는 방법. 출력 이미지의 크기 : m+k-1

- Local connection

    컨볼루션과 동일하지만 픽셀마다 가중치(커널)을 다르게 주는 방법. 

    $$\mathsf Z_{i,j,k} = \sum_{l,m,n}\mathsf V_{l,j+m-1,k+n-1}w_{i,j,k,l,m,n}$$

    ![_config.yml]({{ site.baseurl }}/assets/ch9/Fig9_14.png)

    Top : local connection or unshared convolution

    Center : convolution

    Bottom : full connection

    각각의 특징(feature)가 이미지에서 작은 영역에 대한 함수일 때 사용.

    또한 입력데이터의 특정 채널과 출력데이터의 특정 채널을 연관시킬 때 사용.

    ![_config.yml]({{ site.baseurl }}/assets/ch9/Fig9_15.png)

- Tiled convolution

    특정 주기마다 동일한 커널을 사용하는 방법.

    $$\mathsf Z_{i,j,k} = \sum_{l,m,n}\mathsf V_{l,j+m-1,k+n-1}\mathsf K_{i,l,m,n,j\%t+1,n\%t+1}$$

    % : modulo,  $t$ : the number of different kernels

    ![_config.yml]({{ site.baseurl }}/assets/ch9/Fig9_16.png)

    Top : local connection or unshared convolution

    Center : tiled convolution

    Bottom : convolution

- Backprop

    출력 $\mathsf Z$에 대한 기울기 $\mathsf G_{i,j,k} = \frac{\partial}{\partial \mathsf Z_{i,j,k}} J(\mathsf V, \mathsf K)$가 주어졌을 때, 커널 $\mathsf K$와 입력 $\mathsf V$에 대한 기울기는 다음과 같다.

    $$g(\mathsf G, \mathsf V,s)_{i,j,k,l} = \frac{\partial}{\partial \mathsf K_{i,j,k,l}}J(\mathsf V,\mathsf K) = \sum_{m,n}\mathsf G_{i,m,n}\mathsf V_{j,(m-1)\times s +k, (n-1)\times s +l}$$

    $$g(\mathsf K, \mathsf G,s)_{i,j,k} = \frac{\partial}{\partial \mathsf V_{i,j,k}}J(\mathsf V,\mathsf K) = \sum_{\substack{l,m \\ s.t \\ (l-1)\times s+m=j} }\sum_{\substack{n,p \\ s.t \\ (n-1)\times s+p=k}}\sum_{m,n}\mathsf K_{q,i,m,p}\mathsf G_{q,l,}$$

- Bias

    일반적으로 컨볼루션 레이어에서 바이어스는 각 채널마다 하나의 값을 주고 모든 위치에서 같은 값이 적용되도록 하지만, 위치에 따라 서로 다른 바이어스를 줄 수는 경우도 있다. 

    Ex) 제로 패딩을 했을 경우 이미지의 테두리는 적은 양의 정보를 받아오기 때문에 큰 바이어스를 주는 경우가 있다고 한다. 

## 9.6 Structured Outputs

컨볼루션 네트워크는 클래스 라벨이나 회귀를 위한 하나의 값이 아닌 어떠한 텐서 $\mathsf S$를 출력하도록 만들 수도 있다. 예를 들어, 이미지의 픽셀 $(j,k)$가 클래스 $i$에 속할 확률 $\mathsf S_{i,,j,k}$를 내뱉도록 컨볼루션 네트워크를 만들게 되면, 이미지에 포함된 각각의 물체를 구별할 수 있다.

위와같은 pixel-wise labeling을 하는 한가지 방법으로 가중치를 공유하는 recurrent convolutional network가 있다.

![_config.yml]({{ site.baseurl }}/assets/ch9/Fig9_17.png)

이미지($\mathsf X$)가 히든레이어를 거쳐 출력 $\hat \mathsf Y^{(1)}$을 만들어 내고, 다음 단계에서는 이미지($\mathsf X$)와 이전 단계의 출력 $\hat \mathsf Y^{(1)}$가 입력으로 들어가는 형태이다. 

위의 과정을 반복하여 라벨 추측이 끝나게 되면, 인접해있고 동일한 라벨을 가지는 픽셀들을 하나의 물체로 하여 물체의 구역을 나눌 수 있다.

## 9.7 Data Types

- 1-D
    - Single channel

        Audio waveform

    - Multi-channel

        3D 캐릭터의 애니메이션은 시간이 지남에 따라 골격의 포즈를 변경하여 생성하게 되는데, 각 시점에서 캐릭터의 포즈는 캐릭터의 골격에 있는 각 관절의 각도로 표현할 수 있다. 따라서 각 채널은 한 관절의 하나의 축에 대한 각도가 된다.

- 2-D
    - Single channel

        푸리에 변환으로 표현된 audio waveform. 행 : 시간,  열 : 진동수

    - Multi-channel

        컬러이미지

- 3-D
    - Single channel

        CT 스캔 이미지와 같은 의학 이미지

    - Multi-channel

        컬러 비디오

행렬 곱을 기반으로 한 신경망 같은 경우는 상이한 사이즈의 데이터들을 입력으로 받을 수 없지만(입력 데이터의 사이즈가 바뀌면 가중치 행렬의 크기도 바뀌기 때문) 커널을 사용하는 컨볼루션 네트워크는 상관이 없다. 출력 데이터의 크기가 일정하지 않아도 되는 경우에는 일반적인 컨볼루션을 적용하면 된다. 만일 출력 데이터의 크기가 일정해야 한다면 입력데이터의 크기에 비례하여 크기를 조정하는 풀링 레이어를 사용하면 된다.

당연한 얘기지만, "서로 다른 관측으로 얻어졌기 때문에 데이터들의 사이즈가 상이한 경우"에도 컨볼루션 네트워크를 사용할 수 있다는 것은 아니다. 입력 데이터들이 사이즈는 달라도 동일한 관측으로 얻어진 데이터라면 컨볼루션 네트워크를 사용해도 된다는 것이다.